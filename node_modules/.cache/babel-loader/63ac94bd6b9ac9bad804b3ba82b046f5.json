{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst utils = require('./utils');\n/**\n * Constants\n */\n\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n/**\n * Create the message for a syntax error\n */\n\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n\n  const peek = state.peek = function () {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return input[state.index + n];\n  };\n\n  const advance = state.advance = () => input[++state.index] || '';\n\n  const remaining = () => input.slice(state.index + 1);\n\n  const consume = function () {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value],\n      conditions: 1,\n      inner: ''\n    };\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options,\n          fastpaths: false\n        }).output;\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n  /**\n   * Fast paths\n   */\n\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n    /**\n     * Escaped characters\n     */\n\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * Double quotes\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\n     * Square brackets\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({\n        value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n    /**\n     * Braces\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n\n        for (const t of toks) {\n          state.output += t.output || t.value;\n        }\n      }\n\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n    /**\n     * Pipes\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Commas\n     */\n\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n    /**\n     * Slashes\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Dots\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Question marks\n     */\n\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\n     * Exclamation\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n    /**\n     * Plus\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Stars\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;","map":{"version":3,"names":["constants","require","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","win32","isWindows","PLATFORM_CHARS","globChars","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","chars","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","isGroup","supportsLookbehinds","Error","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","NO_DOTS","slashDot","create","str","source","module","exports"],"sources":["C:/reactnative/TescaroTechAviacaoWeb/node_modules/picomatch/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;AAEA;AACA;AACA;;;AAEA,MAAM;EACJE,UADI;EAEJC,kBAFI;EAGJC,uBAHI;EAIJC,2BAJI;EAKJC;AALI,IAMFP,SANJ;AAQA;AACA;AACA;;AAEA,MAAMQ,WAAW,GAAG,CAACC,IAAD,EAAOC,OAAP,KAAmB;EACrC,IAAI,OAAOA,OAAO,CAACF,WAAf,KAA+B,UAAnC,EAA+C;IAC7C,OAAOE,OAAO,CAACF,WAAR,CAAoB,GAAGC,IAAvB,EAA6BC,OAA7B,CAAP;EACD;;EAEDD,IAAI,CAACE,IAAL;EACA,MAAMC,KAAK,GAAI,IAAGH,IAAI,CAACI,IAAL,CAAU,GAAV,CAAe,GAAjC;;EAEA,IAAI;IACF;IACA,IAAIC,MAAJ,CAAWF,KAAX;EACD,CAHD,CAGE,OAAOG,EAAP,EAAW;IACX,OAAON,IAAI,CAACO,GAAL,CAASC,CAAC,IAAIf,KAAK,CAACgB,WAAN,CAAkBD,CAAlB,CAAd,EAAoCJ,IAApC,CAAyC,IAAzC,CAAP;EACD;;EAED,OAAOD,KAAP;AACD,CAhBD;AAkBA;AACA;AACA;;;AAEA,MAAMO,WAAW,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAgB;EAClC,OAAQ,WAAUD,IAAK,MAAKC,IAAK,gBAAeA,IAAK,+BAArD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,KAAK,GAAG,CAACC,KAAD,EAAQb,OAAR,KAAoB;EAChC,IAAI,OAAOa,KAAP,KAAiB,QAArB,EAA+B;IAC7B,MAAM,IAAIC,SAAJ,CAAc,mBAAd,CAAN;EACD;;EAEDD,KAAK,GAAGhB,YAAY,CAACgB,KAAD,CAAZ,IAAuBA,KAA/B;EAEA,MAAME,IAAI,GAAG,EAAE,GAAGf;EAAL,CAAb;EACA,MAAMgB,GAAG,GAAG,OAAOD,IAAI,CAACE,SAAZ,KAA0B,QAA1B,GAAqCC,IAAI,CAACC,GAAL,CAAS1B,UAAT,EAAqBsB,IAAI,CAACE,SAA1B,CAArC,GAA4ExB,UAAxF;EAEA,IAAI2B,GAAG,GAAGP,KAAK,CAACQ,MAAhB;;EACA,IAAID,GAAG,GAAGJ,GAAV,EAAe;IACb,MAAM,IAAIM,WAAJ,CAAiB,iBAAgBF,GAAI,qCAAoCJ,GAAI,EAA7E,CAAN;EACD;;EAED,MAAMO,GAAG,GAAG;IAAEb,IAAI,EAAE,KAAR;IAAeR,KAAK,EAAE,EAAtB;IAA0BsB,MAAM,EAAET,IAAI,CAACU,OAAL,IAAgB;EAAlD,CAAZ;EACA,MAAMC,MAAM,GAAG,CAACH,GAAD,CAAf;EAEA,MAAMI,OAAO,GAAGZ,IAAI,CAACY,OAAL,GAAe,EAAf,GAAoB,IAApC;EACA,MAAMC,KAAK,GAAGpC,KAAK,CAACqC,SAAN,CAAgB7B,OAAhB,CAAd,CAnBgC,CAqBhC;;EACA,MAAM8B,cAAc,GAAGxC,SAAS,CAACyC,SAAV,CAAoBH,KAApB,CAAvB;EACA,MAAMI,aAAa,GAAG1C,SAAS,CAAC2C,YAAV,CAAuBH,cAAvB,CAAtB;EAEA,MAAM;IACJI,WADI;IAEJC,YAFI;IAGJC,aAHI;IAIJC,QAJI;IAKJC,UALI;IAMJC,MANI;IAOJC,YAPI;IAQJC,aARI;IASJC,KATI;IAUJC,YAVI;IAWJC,IAXI;IAYJC;EAZI,IAaFf,cAbJ;;EAeA,MAAMgB,QAAQ,GAAG/B,IAAI,IAAI;IACvB,OAAQ,IAAGY,OAAQ,SAAQkB,YAAa,GAAE9B,IAAI,CAACgC,GAAL,GAAWT,UAAX,GAAwBJ,WAAY,QAA9E;EACD,CAFD;;EAIA,MAAMc,KAAK,GAAGjC,IAAI,CAACgC,GAAL,GAAW,EAAX,GAAgBR,MAA9B;EACA,MAAMU,UAAU,GAAGlC,IAAI,CAACgC,GAAL,GAAWL,KAAX,GAAmBC,YAAtC;EACA,IAAIO,IAAI,GAAGnC,IAAI,CAACoC,IAAL,KAAc,IAAd,GAAqBL,QAAQ,CAAC/B,IAAD,CAA7B,GAAsC6B,IAAjD;;EAEA,IAAI7B,IAAI,CAACY,OAAT,EAAkB;IAChBuB,IAAI,GAAI,IAAGA,IAAK,GAAhB;EACD,CAlD+B,CAoDhC;;;EACA,IAAI,OAAOnC,IAAI,CAACqC,KAAZ,KAAsB,SAA1B,EAAqC;IACnCrC,IAAI,CAACsC,SAAL,GAAiBtC,IAAI,CAACqC,KAAtB;EACD;;EAED,MAAME,KAAK,GAAG;IACZzC,KADY;IAEZ0C,KAAK,EAAE,CAAC,CAFI;IAGZC,KAAK,EAAE,CAHK;IAIZT,GAAG,EAAEhC,IAAI,CAACgC,GAAL,KAAa,IAJN;IAKZU,QAAQ,EAAE,EALE;IAMZjC,MAAM,EAAE,EANI;IAOZkC,MAAM,EAAE,EAPI;IAQZC,SAAS,EAAE,KARC;IASZC,OAAO,EAAE,KATG;IAUZC,QAAQ,EAAE,CAVE;IAWZC,MAAM,EAAE,CAXI;IAYZC,MAAM,EAAE,CAZI;IAaZC,MAAM,EAAE,CAbI;IAcZlB,QAAQ,EAAE,KAdE;IAeZpB;EAfY,CAAd;EAkBAb,KAAK,GAAGrB,KAAK,CAACyE,YAAN,CAAmBpD,KAAnB,EAA0ByC,KAA1B,CAAR;EACAlC,GAAG,GAAGP,KAAK,CAACQ,MAAZ;EAEA,MAAM6C,QAAQ,GAAG,EAAjB;EACA,MAAMJ,MAAM,GAAG,EAAf;EACA,MAAMK,KAAK,GAAG,EAAd;EACA,IAAIC,IAAI,GAAG7C,GAAX;EACA,IAAIrB,KAAJ;EAEA;AACF;AACA;;EAEE,MAAMmE,GAAG,GAAG,MAAMf,KAAK,CAACC,KAAN,KAAgBnC,GAAG,GAAG,CAAxC;;EACA,MAAMkD,IAAI,GAAGhB,KAAK,CAACgB,IAAN,GAAa;IAAA,IAACC,CAAD,uEAAK,CAAL;IAAA,OAAW1D,KAAK,CAACyC,KAAK,CAACC,KAAN,GAAcgB,CAAf,CAAhB;EAAA,CAA1B;;EACA,MAAMC,OAAO,GAAGlB,KAAK,CAACkB,OAAN,GAAgB,MAAM3D,KAAK,CAAC,EAAEyC,KAAK,CAACC,KAAT,CAAL,IAAwB,EAA9D;;EACA,MAAMkB,SAAS,GAAG,MAAM5D,KAAK,CAAC6D,KAAN,CAAYpB,KAAK,CAACC,KAAN,GAAc,CAA1B,CAAxB;;EACA,MAAMoB,OAAO,GAAG,YAAyB;IAAA,IAAxBzE,KAAwB,uEAAhB,EAAgB;IAAA,IAAZ0E,GAAY,uEAAN,CAAM;IACvCtB,KAAK,CAACG,QAAN,IAAkBvD,KAAlB;IACAoD,KAAK,CAACC,KAAN,IAAeqB,GAAf;EACD,CAHD;;EAKA,MAAMC,MAAM,GAAGC,KAAK,IAAI;IACtBxB,KAAK,CAAC9B,MAAN,IAAgBsD,KAAK,CAACtD,MAAN,IAAgB,IAAhB,GAAuBsD,KAAK,CAACtD,MAA7B,GAAsCsD,KAAK,CAAC5E,KAA5D;IACAyE,OAAO,CAACG,KAAK,CAAC5E,KAAP,CAAP;EACD,CAHD;;EAKA,MAAM6E,MAAM,GAAG,MAAM;IACnB,IAAIC,KAAK,GAAG,CAAZ;;IAEA,OAAOV,IAAI,OAAO,GAAX,KAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAlD,CAAP,EAA+D;MAC7DE,OAAO;MACPlB,KAAK,CAACE,KAAN;MACAwB,KAAK;IACN;;IAED,IAAIA,KAAK,GAAG,CAAR,KAAc,CAAlB,EAAqB;MACnB,OAAO,KAAP;IACD;;IAED1B,KAAK,CAACM,OAAN,GAAgB,IAAhB;IACAN,KAAK,CAACE,KAAN;IACA,OAAO,IAAP;EACD,CAhBD;;EAkBA,MAAMyB,SAAS,GAAGvE,IAAI,IAAI;IACxB4C,KAAK,CAAC5C,IAAD,CAAL;IACAyD,KAAK,CAACe,IAAN,CAAWxE,IAAX;EACD,CAHD;;EAKA,MAAMyE,SAAS,GAAGzE,IAAI,IAAI;IACxB4C,KAAK,CAAC5C,IAAD,CAAL;IACAyD,KAAK,CAACiB,GAAN;EACD,CAHD;EAKA;AACF;AACA;AACA;AACA;AACA;AACA;;;EAEE,MAAMF,IAAI,GAAGG,GAAG,IAAI;IAClB,IAAIjB,IAAI,CAAC1D,IAAL,KAAc,UAAlB,EAA8B;MAC5B,MAAM4E,OAAO,GAAGhC,KAAK,CAACQ,MAAN,GAAe,CAAf,KAAqBuB,GAAG,CAAC3E,IAAJ,KAAa,OAAb,IAAwB2E,GAAG,CAAC3E,IAAJ,KAAa,OAA1D,CAAhB;MACA,MAAM6E,SAAS,GAAGF,GAAG,CAACG,OAAJ,KAAgB,IAAhB,IAAyBtB,QAAQ,CAAC7C,MAAT,KAAoBgE,GAAG,CAAC3E,IAAJ,KAAa,MAAb,IAAuB2E,GAAG,CAAC3E,IAAJ,KAAa,OAAxD,CAA3C;;MAEA,IAAI2E,GAAG,CAAC3E,IAAJ,KAAa,OAAb,IAAwB2E,GAAG,CAAC3E,IAAJ,KAAa,OAArC,IAAgD,CAAC4E,OAAjD,IAA4D,CAACC,SAAjE,EAA4E;QAC1EjC,KAAK,CAAC9B,MAAN,GAAe8B,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsB,CAACN,IAAI,CAAC5C,MAAL,CAAYH,MAAnC,CAAf;QACA+C,IAAI,CAAC1D,IAAL,GAAY,MAAZ;QACA0D,IAAI,CAAClE,KAAL,GAAa,GAAb;QACAkE,IAAI,CAAC5C,MAAL,GAAc0B,IAAd;QACAI,KAAK,CAAC9B,MAAN,IAAgB4C,IAAI,CAAC5C,MAArB;MACD;IACF;;IAED,IAAI0C,QAAQ,CAAC7C,MAAT,IAAmBgE,GAAG,CAAC3E,IAAJ,KAAa,OAApC,EAA6C;MAC3CwD,QAAQ,CAACA,QAAQ,CAAC7C,MAAT,GAAkB,CAAnB,CAAR,CAA8BoE,KAA9B,IAAuCJ,GAAG,CAACnF,KAA3C;IACD;;IAED,IAAImF,GAAG,CAACnF,KAAJ,IAAamF,GAAG,CAAC7D,MAArB,EAA6BqD,MAAM,CAACQ,GAAD,CAAN;;IAC7B,IAAIjB,IAAI,IAAIA,IAAI,CAAC1D,IAAL,KAAc,MAAtB,IAAgC2E,GAAG,CAAC3E,IAAJ,KAAa,MAAjD,EAAyD;MACvD0D,IAAI,CAAClE,KAAL,IAAcmF,GAAG,CAACnF,KAAlB;MACAkE,IAAI,CAAC5C,MAAL,GAAc,CAAC4C,IAAI,CAAC5C,MAAL,IAAe,EAAhB,IAAsB6D,GAAG,CAACnF,KAAxC;MACA;IACD;;IAEDmF,GAAG,CAACjB,IAAJ,GAAWA,IAAX;IACA1C,MAAM,CAACwD,IAAP,CAAYG,GAAZ;IACAjB,IAAI,GAAGiB,GAAP;EACD,CA5BD;;EA8BA,MAAMK,WAAW,GAAG,CAAChF,IAAD,EAAOR,KAAP,KAAiB;IACnC,MAAM4E,KAAK,GAAG,EAAE,GAAG9C,aAAa,CAAC9B,KAAD,CAAlB;MAA2ByF,UAAU,EAAE,CAAvC;MAA0CF,KAAK,EAAE;IAAjD,CAAd;IAEAX,KAAK,CAACV,IAAN,GAAaA,IAAb;IACAU,KAAK,CAACf,MAAN,GAAeT,KAAK,CAACS,MAArB;IACAe,KAAK,CAACtD,MAAN,GAAe8B,KAAK,CAAC9B,MAArB;IACA,MAAMA,MAAM,GAAG,CAACT,IAAI,CAACY,OAAL,GAAe,GAAf,GAAqB,EAAtB,IAA4BmD,KAAK,CAACc,IAAjD;IAEAX,SAAS,CAAC,QAAD,CAAT;IACAC,IAAI,CAAC;MAAExE,IAAF;MAAQR,KAAR;MAAesB,MAAM,EAAE8B,KAAK,CAAC9B,MAAN,GAAe,EAAf,GAAoBa;IAA3C,CAAD,CAAJ;IACA6C,IAAI,CAAC;MAAExE,IAAI,EAAE,OAAR;MAAiB8E,OAAO,EAAE,IAA1B;MAAgCtF,KAAK,EAAEsE,OAAO,EAA9C;MAAkDhD;IAAlD,CAAD,CAAJ;IACA0C,QAAQ,CAACgB,IAAT,CAAcJ,KAAd;EACD,CAZD;;EAcA,MAAMe,YAAY,GAAGf,KAAK,IAAI;IAC5B,IAAItD,MAAM,GAAGsD,KAAK,CAACgB,KAAN,IAAe/E,IAAI,CAACY,OAAL,GAAe,GAAf,GAAqB,EAApC,CAAb;IACA,IAAIoE,IAAJ;;IAEA,IAAIjB,KAAK,CAACpE,IAAN,KAAe,QAAnB,EAA6B;MAC3B,IAAIsF,WAAW,GAAG9C,IAAlB;;MAEA,IAAI4B,KAAK,CAACW,KAAN,IAAeX,KAAK,CAACW,KAAN,CAAYpE,MAAZ,GAAqB,CAApC,IAAyCyD,KAAK,CAACW,KAAN,CAAYQ,QAAZ,CAAqB,GAArB,CAA7C,EAAwE;QACtED,WAAW,GAAGlD,QAAQ,CAAC/B,IAAD,CAAtB;MACD;;MAED,IAAIiF,WAAW,KAAK9C,IAAhB,IAAwBmB,GAAG,EAA3B,IAAiC,QAAQ6B,IAAR,CAAazB,SAAS,EAAtB,CAArC,EAAgE;QAC9DjD,MAAM,GAAGsD,KAAK,CAACgB,KAAN,GAAe,OAAME,WAAY,EAA1C;MACD;;MAED,IAAIlB,KAAK,CAACW,KAAN,CAAYQ,QAAZ,CAAqB,GAArB,MAA8BF,IAAI,GAAGtB,SAAS,EAA9C,KAAqD,eAAeyB,IAAf,CAAoBH,IAApB,CAAzD,EAAoF;QAClF;QACA;QACA;QACA;QACA;QACA,MAAMI,UAAU,GAAGvF,KAAK,CAACmF,IAAD,EAAO,EAAE,GAAG/F,OAAL;UAAcoG,SAAS,EAAE;QAAzB,CAAP,CAAL,CAA8C5E,MAAjE;QAEAA,MAAM,GAAGsD,KAAK,CAACgB,KAAN,GAAe,IAAGK,UAAW,IAAGH,WAAY,GAArD;MACD;;MAED,IAAIlB,KAAK,CAACV,IAAN,CAAW1D,IAAX,KAAoB,KAAxB,EAA+B;QAC7B4C,KAAK,CAAC+C,cAAN,GAAuB,IAAvB;MACD;IACF;;IAEDnB,IAAI,CAAC;MAAExE,IAAI,EAAE,OAAR;MAAiB8E,OAAO,EAAE,IAA1B;MAAgCtF,KAAhC;MAAuCsB;IAAvC,CAAD,CAAJ;IACA2D,SAAS,CAAC,QAAD,CAAT;EACD,CAjCD;EAmCA;AACF;AACA;;;EAEE,IAAIpE,IAAI,CAACqF,SAAL,KAAmB,KAAnB,IAA4B,CAAC,sBAAsBF,IAAtB,CAA2BrF,KAA3B,CAAjC,EAAoE;IAClE,IAAIyF,WAAW,GAAG,KAAlB;IAEA,IAAI9E,MAAM,GAAGX,KAAK,CAAC0F,OAAN,CAAc3G,2BAAd,EAA2C,CAAC4G,CAAD,EAAIC,GAAJ,EAASC,KAAT,EAAgBC,KAAhB,EAAuBZ,IAAvB,EAA6BxC,KAA7B,KAAuC;MAC7F,IAAIoD,KAAK,KAAK,IAAd,EAAoB;QAClBL,WAAW,GAAG,IAAd;QACA,OAAOE,CAAP;MACD;;MAED,IAAIG,KAAK,KAAK,GAAd,EAAmB;QACjB,IAAIF,GAAJ,EAAS;UACP,OAAOA,GAAG,GAAGE,KAAN,IAAeZ,IAAI,GAAGrD,KAAK,CAACkE,MAAN,CAAab,IAAI,CAAC1E,MAAlB,CAAH,GAA+B,EAAlD,CAAP;QACD;;QACD,IAAIkC,KAAK,KAAK,CAAd,EAAiB;UACf,OAAON,UAAU,IAAI8C,IAAI,GAAGrD,KAAK,CAACkE,MAAN,CAAab,IAAI,CAAC1E,MAAlB,CAAH,GAA+B,EAAvC,CAAjB;QACD;;QACD,OAAOqB,KAAK,CAACkE,MAAN,CAAaF,KAAK,CAACrF,MAAnB,CAAP;MACD;;MAED,IAAIsF,KAAK,KAAK,GAAd,EAAmB;QACjB,OAAOzE,WAAW,CAAC0E,MAAZ,CAAmBF,KAAK,CAACrF,MAAzB,CAAP;MACD;;MAED,IAAIsF,KAAK,KAAK,GAAd,EAAmB;QACjB,IAAIF,GAAJ,EAAS;UACP,OAAOA,GAAG,GAAGE,KAAN,IAAeZ,IAAI,GAAG7C,IAAH,GAAU,EAA7B,CAAP;QACD;;QACD,OAAOA,IAAP;MACD;;MACD,OAAOuD,GAAG,GAAGD,CAAH,GAAQ,KAAIA,CAAE,EAAxB;IACD,CA3BY,CAAb;;IA6BA,IAAIF,WAAW,KAAK,IAApB,EAA0B;MACxB,IAAIvF,IAAI,CAAC8F,QAAL,KAAkB,IAAtB,EAA4B;QAC1BrF,MAAM,GAAGA,MAAM,CAAC+E,OAAP,CAAe,KAAf,EAAsB,EAAtB,CAAT;MACD,CAFD,MAEO;QACL/E,MAAM,GAAGA,MAAM,CAAC+E,OAAP,CAAe,MAAf,EAAuBC,CAAC,IAAI;UACnC,OAAOA,CAAC,CAACnF,MAAF,GAAW,CAAX,KAAiB,CAAjB,GAAqB,MAArB,GAA+BmF,CAAC,GAAG,IAAH,GAAU,EAAjD;QACD,CAFQ,CAAT;MAGD;IACF;;IAED,IAAIhF,MAAM,KAAKX,KAAX,IAAoBE,IAAI,CAAC+F,QAAL,KAAkB,IAA1C,EAAgD;MAC9CxD,KAAK,CAAC9B,MAAN,GAAeX,KAAf;MACA,OAAOyC,KAAP;IACD;;IAEDA,KAAK,CAAC9B,MAAN,GAAehC,KAAK,CAACuH,UAAN,CAAiBvF,MAAjB,EAAyB8B,KAAzB,EAAgCtD,OAAhC,CAAf;IACA,OAAOsD,KAAP;EACD;EAED;AACF;AACA;;;EAEE,OAAO,CAACe,GAAG,EAAX,EAAe;IACbnE,KAAK,GAAGsE,OAAO,EAAf;;IAEA,IAAItE,KAAK,KAAK,QAAd,EAAwB;MACtB;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,IAAd,EAAoB;MAClB,MAAM8G,IAAI,GAAG1C,IAAI,EAAjB;;MAEA,IAAI0C,IAAI,KAAK,GAAT,IAAgBjG,IAAI,CAACoC,IAAL,KAAc,IAAlC,EAAwC;QACtC;MACD;;MAED,IAAI6D,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,GAA7B,EAAkC;QAChC;MACD;;MAED,IAAI,CAACA,IAAL,EAAW;QACT9G,KAAK,IAAI,IAAT;QACAgF,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR;QAAhB,CAAD,CAAJ;QACA;MACD,CAfiB,CAiBlB;;;MACA,MAAM+G,KAAK,GAAG,OAAOC,IAAP,CAAYzC,SAAS,EAArB,CAAd;MACA,IAAI0C,OAAO,GAAG,CAAd;;MAEA,IAAIF,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAL,CAAS5F,MAAT,GAAkB,CAA/B,EAAkC;QAChC8F,OAAO,GAAGF,KAAK,CAAC,CAAD,CAAL,CAAS5F,MAAnB;QACAiC,KAAK,CAACC,KAAN,IAAe4D,OAAf;;QACA,IAAIA,OAAO,GAAG,CAAV,KAAgB,CAApB,EAAuB;UACrBjH,KAAK,IAAI,IAAT;QACD;MACF;;MAED,IAAIa,IAAI,CAAC8F,QAAL,KAAkB,IAAtB,EAA4B;QAC1B3G,KAAK,GAAGsE,OAAO,EAAf;MACD,CAFD,MAEO;QACLtE,KAAK,IAAIsE,OAAO,EAAhB;MACD;;MAED,IAAIlB,KAAK,CAACO,QAAN,KAAmB,CAAvB,EAA0B;QACxBqB,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR;QAAhB,CAAD,CAAJ;QACA;MACD;IACF;IAED;AACJ;AACA;AACA;;;IAEI,IAAIoD,KAAK,CAACO,QAAN,GAAiB,CAAjB,KAAuB3D,KAAK,KAAK,GAAV,IAAiBkE,IAAI,CAAClE,KAAL,KAAe,GAAhC,IAAuCkE,IAAI,CAAClE,KAAL,KAAe,IAA7E,CAAJ,EAAwF;MACtF,IAAIa,IAAI,CAACqG,KAAL,KAAe,KAAf,IAAwBlH,KAAK,KAAK,GAAtC,EAA2C;QACzC,MAAMuF,KAAK,GAAGrB,IAAI,CAAClE,KAAL,CAAWwE,KAAX,CAAiB,CAAjB,CAAd;;QACA,IAAIe,KAAK,CAACQ,QAAN,CAAe,GAAf,CAAJ,EAAyB;UACvB7B,IAAI,CAACgD,KAAL,GAAa,IAAb;;UAEA,IAAI3B,KAAK,CAACQ,QAAN,CAAe,GAAf,CAAJ,EAAyB;YACvB,MAAMoB,GAAG,GAAGjD,IAAI,CAAClE,KAAL,CAAWoH,WAAX,CAAuB,GAAvB,CAAZ;YACA,MAAMC,GAAG,GAAGnD,IAAI,CAAClE,KAAL,CAAWwE,KAAX,CAAiB,CAAjB,EAAoB2C,GAApB,CAAZ;YACA,MAAMtB,IAAI,GAAG3B,IAAI,CAAClE,KAAL,CAAWwE,KAAX,CAAiB2C,GAAG,GAAG,CAAvB,CAAb;YACA,MAAMD,KAAK,GAAG1H,kBAAkB,CAACqG,IAAD,CAAhC;;YACA,IAAIqB,KAAJ,EAAW;cACThD,IAAI,CAAClE,KAAL,GAAaqH,GAAG,GAAGH,KAAnB;cACA9D,KAAK,CAACK,SAAN,GAAkB,IAAlB;cACAa,OAAO;;cAEP,IAAI,CAACjD,GAAG,CAACC,MAAL,IAAeE,MAAM,CAAC8F,OAAP,CAAepD,IAAf,MAAyB,CAA5C,EAA+C;gBAC7C7C,GAAG,CAACC,MAAJ,GAAaa,QAAb;cACD;;cACD;YACD;UACF;QACF;MACF;;MAED,IAAKnC,KAAK,KAAK,GAAV,IAAiBoE,IAAI,OAAO,GAA7B,IAAsCpE,KAAK,KAAK,GAAV,IAAiBoE,IAAI,OAAO,GAAtE,EAA4E;QAC1EpE,KAAK,GAAI,KAAIA,KAAM,EAAnB;MACD;;MAED,IAAIA,KAAK,KAAK,GAAV,KAAkBkE,IAAI,CAAClE,KAAL,KAAe,GAAf,IAAsBkE,IAAI,CAAClE,KAAL,KAAe,IAAvD,CAAJ,EAAkE;QAChEA,KAAK,GAAI,KAAIA,KAAM,EAAnB;MACD;;MAED,IAAIa,IAAI,CAACqG,KAAL,KAAe,IAAf,IAAuBlH,KAAK,KAAK,GAAjC,IAAwCkE,IAAI,CAAClE,KAAL,KAAe,GAA3D,EAAgE;QAC9DA,KAAK,GAAG,GAAR;MACD;;MAEDkE,IAAI,CAAClE,KAAL,IAAcA,KAAd;MACA2E,MAAM,CAAC;QAAE3E;MAAF,CAAD,CAAN;MACA;IACD;IAED;AACJ;AACA;AACA;;;IAEI,IAAIoD,KAAK,CAACU,MAAN,KAAiB,CAAjB,IAAsB9D,KAAK,KAAK,GAApC,EAAyC;MACvCA,KAAK,GAAGV,KAAK,CAACgB,WAAN,CAAkBN,KAAlB,CAAR;MACAkE,IAAI,CAAClE,KAAL,IAAcA,KAAd;MACA2E,MAAM,CAAC;QAAE3E;MAAF,CAAD,CAAN;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjBoD,KAAK,CAACU,MAAN,GAAeV,KAAK,CAACU,MAAN,KAAiB,CAAjB,GAAqB,CAArB,GAAyB,CAAxC;;MACA,IAAIjD,IAAI,CAAC0G,UAAL,KAAoB,IAAxB,EAA8B;QAC5BvC,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR;QAAhB,CAAD,CAAJ;MACD;;MACD;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjB+E,SAAS,CAAC,QAAD,CAAT;MACAC,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR;MAAjB,CAAD,CAAJ;MACA;IACD;;IAED,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIoD,KAAK,CAACS,MAAN,KAAiB,CAAjB,IAAsBhD,IAAI,CAAC2G,cAAL,KAAwB,IAAlD,EAAwD;QACtD,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;MACD;;MAED,MAAM+E,OAAO,GAAGtB,QAAQ,CAACA,QAAQ,CAAC7C,MAAT,GAAkB,CAAnB,CAAxB;;MACA,IAAImE,OAAO,IAAIlC,KAAK,CAACS,MAAN,KAAiByB,OAAO,CAACzB,MAAR,GAAiB,CAAjD,EAAoD;QAClD8B,YAAY,CAAC3B,QAAQ,CAACkB,GAAT,EAAD,CAAZ;QACA;MACD;;MAEDF,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR,KAAjB;QAAwBsB,MAAM,EAAE8B,KAAK,CAACS,MAAN,GAAe,GAAf,GAAqB;MAArD,CAAD,CAAJ;MACAoB,SAAS,CAAC,QAAD,CAAT;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIjF,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIa,IAAI,CAAC4G,SAAL,KAAmB,IAAnB,IAA2B,CAAClD,SAAS,GAAGwB,QAAZ,CAAqB,GAArB,CAAhC,EAA2D;QACzD,IAAIlF,IAAI,CAAC4G,SAAL,KAAmB,IAAnB,IAA2B5G,IAAI,CAAC2G,cAAL,KAAwB,IAAvD,EAA6D;UAC3D,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;QACD;;QAEDP,KAAK,GAAI,KAAIA,KAAM,EAAnB;MACD,CAND,MAMO;QACL+E,SAAS,CAAC,UAAD,CAAT;MACD;;MAEDC,IAAI,CAAC;QAAExE,IAAI,EAAE,SAAR;QAAmBR;MAAnB,CAAD,CAAJ;MACA;IACD;;IAED,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIa,IAAI,CAAC4G,SAAL,KAAmB,IAAnB,IAA4BvD,IAAI,IAAIA,IAAI,CAAC1D,IAAL,KAAc,SAAtB,IAAmC0D,IAAI,CAAClE,KAAL,CAAWmB,MAAX,KAAsB,CAAzF,EAA6F;QAC3F6D,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAG,KAAItB,KAAM;QAA1C,CAAD,CAAJ;QACA;MACD;;MAED,IAAIoD,KAAK,CAACO,QAAN,KAAmB,CAAvB,EAA0B;QACxB,IAAI9C,IAAI,CAAC2G,cAAL,KAAwB,IAA5B,EAAkC;UAChC,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;QACD;;QAEDyE,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAG,KAAItB,KAAM;QAA1C,CAAD,CAAJ;QACA;MACD;;MAEDiF,SAAS,CAAC,UAAD,CAAT;MAEA,MAAMyC,SAAS,GAAGxD,IAAI,CAAClE,KAAL,CAAWwE,KAAX,CAAiB,CAAjB,CAAlB;;MACA,IAAIN,IAAI,CAACgD,KAAL,KAAe,IAAf,IAAuBQ,SAAS,CAAC,CAAD,CAAT,KAAiB,GAAxC,IAA+C,CAACA,SAAS,CAAC3B,QAAV,CAAmB,GAAnB,CAApD,EAA6E;QAC3E/F,KAAK,GAAI,IAAGA,KAAM,EAAlB;MACD;;MAEDkE,IAAI,CAAClE,KAAL,IAAcA,KAAd;MACA2E,MAAM,CAAC;QAAE3E;MAAF,CAAD,CAAN,CAvBiB,CAyBjB;MACA;;MACA,IAAIa,IAAI,CAAC8G,eAAL,KAAyB,KAAzB,IAAkCrI,KAAK,CAACsI,aAAN,CAAoBF,SAApB,CAAtC,EAAsE;QACpE;MACD;;MAED,MAAMG,OAAO,GAAGvI,KAAK,CAACgB,WAAN,CAAkB4D,IAAI,CAAClE,KAAvB,CAAhB;MACAoD,KAAK,CAAC9B,MAAN,GAAe8B,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsB,CAACN,IAAI,CAAClE,KAAL,CAAWmB,MAAlC,CAAf,CAhCiB,CAkCjB;MACA;;MACA,IAAIN,IAAI,CAAC8G,eAAL,KAAyB,IAA7B,EAAmC;QACjCvE,KAAK,CAAC9B,MAAN,IAAgBuG,OAAhB;QACA3D,IAAI,CAAClE,KAAL,GAAa6H,OAAb;QACA;MACD,CAxCgB,CA0CjB;;;MACA3D,IAAI,CAAClE,KAAL,GAAc,IAAGyB,OAAQ,GAAEoG,OAAQ,IAAG3D,IAAI,CAAClE,KAAM,GAAjD;MACAoD,KAAK,CAAC9B,MAAN,IAAgB4C,IAAI,CAAClE,KAArB;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,GAAV,IAAiBa,IAAI,CAACiH,OAAL,KAAiB,IAAtC,EAA4C;MAC1C/C,SAAS,CAAC,QAAD,CAAT;MAEA,MAAMW,IAAI,GAAG;QACXlF,IAAI,EAAE,OADK;QAEXR,KAFW;QAGXsB,MAAM,EAAE,GAHG;QAIXyG,WAAW,EAAE3E,KAAK,CAAC9B,MAAN,CAAaH,MAJf;QAKX6G,WAAW,EAAE5E,KAAK,CAAC5B,MAAN,CAAaL;MALf,CAAb;MAQAyC,MAAM,CAACoB,IAAP,CAAYU,IAAZ;MACAV,IAAI,CAACU,IAAD,CAAJ;MACA;IACD;;IAED,IAAI1F,KAAK,KAAK,GAAd,EAAmB;MACjB,MAAMiI,KAAK,GAAGrE,MAAM,CAACA,MAAM,CAACzC,MAAP,GAAgB,CAAjB,CAApB;;MAEA,IAAIN,IAAI,CAACiH,OAAL,KAAiB,IAAjB,IAAyB,CAACG,KAA9B,EAAqC;QACnCjD,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAEtB;QAA/B,CAAD,CAAJ;QACA;MACD;;MAED,IAAIsB,MAAM,GAAG,GAAb;;MAEA,IAAI2G,KAAK,CAACC,IAAN,KAAe,IAAnB,EAAyB;QACvB,MAAMC,GAAG,GAAG3G,MAAM,CAACgD,KAAP,EAAZ;QACA,MAAM4D,KAAK,GAAG,EAAd;;QAEA,KAAK,IAAIC,CAAC,GAAGF,GAAG,CAAChH,MAAJ,GAAa,CAA1B,EAA6BkH,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;UACxC7G,MAAM,CAAC0D,GAAP;;UACA,IAAIiD,GAAG,CAACE,CAAD,CAAH,CAAO7H,IAAP,KAAgB,OAApB,EAA6B;YAC3B;UACD;;UACD,IAAI2H,GAAG,CAACE,CAAD,CAAH,CAAO7H,IAAP,KAAgB,MAApB,EAA4B;YAC1B4H,KAAK,CAACE,OAAN,CAAcH,GAAG,CAACE,CAAD,CAAH,CAAOrI,KAArB;UACD;QACF;;QAEDsB,MAAM,GAAG1B,WAAW,CAACwI,KAAD,EAAQvH,IAAR,CAApB;QACAuC,KAAK,CAACK,SAAN,GAAkB,IAAlB;MACD;;MAED,IAAIwE,KAAK,CAACM,KAAN,KAAgB,IAAhB,IAAwBN,KAAK,CAACC,IAAN,KAAe,IAA3C,EAAiD;QAC/C,MAAMM,GAAG,GAAGpF,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsByD,KAAK,CAACF,WAA5B,CAAZ;QACA,MAAMU,IAAI,GAAGrF,KAAK,CAAC5B,MAAN,CAAagD,KAAb,CAAmByD,KAAK,CAACD,WAAzB,CAAb;QACAC,KAAK,CAACjI,KAAN,GAAciI,KAAK,CAAC3G,MAAN,GAAe,KAA7B;QACAtB,KAAK,GAAGsB,MAAM,GAAG,KAAjB;QACA8B,KAAK,CAAC9B,MAAN,GAAekH,GAAf;;QACA,KAAK,MAAME,CAAX,IAAgBD,IAAhB,EAAsB;UACpBrF,KAAK,CAAC9B,MAAN,IAAiBoH,CAAC,CAACpH,MAAF,IAAYoH,CAAC,CAAC1I,KAA/B;QACD;MACF;;MAEDgF,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR,KAAjB;QAAwBsB;MAAxB,CAAD,CAAJ;MACA2D,SAAS,CAAC,QAAD,CAAT;MACArB,MAAM,CAACsB,GAAP;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIlF,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIgE,QAAQ,CAAC7C,MAAT,GAAkB,CAAtB,EAAyB;QACvB6C,QAAQ,CAACA,QAAQ,CAAC7C,MAAT,GAAkB,CAAnB,CAAR,CAA8BsE,UAA9B;MACD;;MACDT,IAAI,CAAC;QAAExE,IAAI,EAAE,MAAR;QAAgBR;MAAhB,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIsB,MAAM,GAAGtB,KAAb;MAEA,MAAMiI,KAAK,GAAGrE,MAAM,CAACA,MAAM,CAACzC,MAAP,GAAgB,CAAjB,CAApB;;MACA,IAAI8G,KAAK,IAAIhE,KAAK,CAACA,KAAK,CAAC9C,MAAN,GAAe,CAAhB,CAAL,KAA4B,QAAzC,EAAmD;QACjD8G,KAAK,CAACM,KAAN,GAAc,IAAd;QACAjH,MAAM,GAAG,GAAT;MACD;;MAED0D,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR,KAAjB;QAAwBsB;MAAxB,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAItB,KAAK,KAAK,GAAd,EAAmB;MACjB;MACA;MACA;MACA;MACA,IAAIkE,IAAI,CAAC1D,IAAL,KAAc,KAAd,IAAuB4C,KAAK,CAACC,KAAN,KAAgBD,KAAK,CAACE,KAAN,GAAc,CAAzD,EAA4D;QAC1DF,KAAK,CAACE,KAAN,GAAcF,KAAK,CAACC,KAAN,GAAc,CAA5B;QACAD,KAAK,CAACG,QAAN,GAAiB,EAAjB;QACAH,KAAK,CAAC9B,MAAN,GAAe,EAAf;QACAE,MAAM,CAAC0D,GAAP;QACAhB,IAAI,GAAG7C,GAAP,CAL0D,CAK9C;;QACZ;MACD;;MAED2D,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR,KAAjB;QAAwBsB,MAAM,EAAEY;MAAhC,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIlC,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIoD,KAAK,CAACQ,MAAN,GAAe,CAAf,IAAoBM,IAAI,CAAC1D,IAAL,KAAc,KAAtC,EAA6C;QAC3C,IAAI0D,IAAI,CAAClE,KAAL,KAAe,GAAnB,EAAwBkE,IAAI,CAAC5C,MAAL,GAAcU,WAAd;QACxB,MAAMiG,KAAK,GAAGrE,MAAM,CAACA,MAAM,CAACzC,MAAP,GAAgB,CAAjB,CAApB;QACA+C,IAAI,CAAC1D,IAAL,GAAY,MAAZ;QACA0D,IAAI,CAAC5C,MAAL,IAAetB,KAAf;QACAkE,IAAI,CAAClE,KAAL,IAAcA,KAAd;QACAiI,KAAK,CAACC,IAAN,GAAa,IAAb;QACA;MACD;;MAED,IAAK9E,KAAK,CAACQ,MAAN,GAAeR,KAAK,CAACS,MAAtB,KAAkC,CAAlC,IAAuCK,IAAI,CAAC1D,IAAL,KAAc,KAArD,IAA8D0D,IAAI,CAAC1D,IAAL,KAAc,OAAhF,EAAyF;QACvFwE,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAEU;QAA/B,CAAD,CAAJ;QACA;MACD;;MAEDgD,IAAI,CAAC;QAAExE,IAAI,EAAE,KAAR;QAAeR,KAAf;QAAsBsB,MAAM,EAAEU;MAA9B,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIhC,KAAK,KAAK,GAAd,EAAmB;MACjB,MAAM2I,OAAO,GAAGzE,IAAI,IAAIA,IAAI,CAAClE,KAAL,KAAe,GAAvC;;MACA,IAAI,CAAC2I,OAAD,IAAY9H,IAAI,CAACsC,SAAL,KAAmB,IAA/B,IAAuCiB,IAAI,OAAO,GAAlD,IAAyDA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAzE,EAA8E;QAC5EoB,WAAW,CAAC,OAAD,EAAUxF,KAAV,CAAX;QACA;MACD;;MAED,IAAIkE,IAAI,IAAIA,IAAI,CAAC1D,IAAL,KAAc,OAA1B,EAAmC;QACjC,MAAMsG,IAAI,GAAG1C,IAAI,EAAjB;QACA,IAAI9C,MAAM,GAAGtB,KAAb;;QAEA,IAAI8G,IAAI,KAAK,GAAT,IAAgB,CAACxH,KAAK,CAACsJ,mBAAN,EAArB,EAAkD;UAChD,MAAM,IAAIC,KAAJ,CAAU,yDAAV,CAAN;QACD;;QAED,IAAK3E,IAAI,CAAClE,KAAL,KAAe,GAAf,IAAsB,CAAC,SAASgG,IAAT,CAAcc,IAAd,CAAxB,IAAiDA,IAAI,KAAK,GAAT,IAAgB,CAAC,eAAed,IAAf,CAAoBzB,SAAS,EAA7B,CAAtE,EAAyG;UACvGjD,MAAM,GAAI,KAAItB,KAAM,EAApB;QACD;;QAEDgF,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB;QAAvB,CAAD,CAAJ;QACA;MACD;;MAED,IAAIT,IAAI,CAACgC,GAAL,KAAa,IAAb,KAAsBqB,IAAI,CAAC1D,IAAL,KAAc,OAAd,IAAyB0D,IAAI,CAAC1D,IAAL,KAAc,KAA7D,CAAJ,EAAyE;QACvEwE,IAAI,CAAC;UAAExE,IAAI,EAAE,OAAR;UAAiBR,KAAjB;UAAwBsB,MAAM,EAAEmB;QAAhC,CAAD,CAAJ;QACA;MACD;;MAEDuC,IAAI,CAAC;QAAExE,IAAI,EAAE,OAAR;QAAiBR,KAAjB;QAAwBsB,MAAM,EAAEkB;MAAhC,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIxC,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIa,IAAI,CAACsC,SAAL,KAAmB,IAAnB,IAA2BiB,IAAI,OAAO,GAA1C,EAA+C;QAC7C,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmB,CAAC,SAAS4B,IAAT,CAAc5B,IAAI,CAAC,CAAD,CAAlB,CAAxB,EAAgD;UAC9CoB,WAAW,CAAC,QAAD,EAAWxF,KAAX,CAAX;UACA;QACD;MACF;;MAED,IAAIa,IAAI,CAACiI,QAAL,KAAkB,IAAlB,IAA0B1F,KAAK,CAACC,KAAN,KAAgB,CAA9C,EAAiD;QAC/CwB,MAAM;QACN;MACD;IACF;IAED;AACJ;AACA;;;IAEI,IAAI7E,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIa,IAAI,CAACsC,SAAL,KAAmB,IAAnB,IAA2BiB,IAAI,OAAO,GAAtC,IAA6CA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA7D,EAAkE;QAChEoB,WAAW,CAAC,MAAD,EAASxF,KAAT,CAAX;QACA;MACD;;MAED,IAAKkE,IAAI,IAAIA,IAAI,CAAClE,KAAL,KAAe,GAAxB,IAAgCa,IAAI,CAACkI,KAAL,KAAe,KAAnD,EAA0D;QACxD/D,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAEW;QAA/B,CAAD,CAAJ;QACA;MACD;;MAED,IAAKiC,IAAI,KAAKA,IAAI,CAAC1D,IAAL,KAAc,SAAd,IAA2B0D,IAAI,CAAC1D,IAAL,KAAc,OAAzC,IAAoD0D,IAAI,CAAC1D,IAAL,KAAc,OAAvE,CAAL,IAAyF4C,KAAK,CAACS,MAAN,GAAe,CAA5G,EAA+G;QAC7GmB,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR;QAAhB,CAAD,CAAJ;QACA;MACD;;MAEDgF,IAAI,CAAC;QAAExE,IAAI,EAAE,MAAR;QAAgBR,KAAK,EAAEiC;MAAvB,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIjC,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIa,IAAI,CAACsC,SAAL,KAAmB,IAAnB,IAA2BiB,IAAI,OAAO,GAAtC,IAA6CA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA7D,EAAkE;QAChEY,IAAI,CAAC;UAAExE,IAAI,EAAE,IAAR;UAAc8E,OAAO,EAAE,IAAvB;UAA6BtF,KAA7B;UAAoCsB,MAAM,EAAE;QAA5C,CAAD,CAAJ;QACA;MACD;;MAED0D,IAAI,CAAC;QAAExE,IAAI,EAAE,MAAR;QAAgBR;MAAhB,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjB,IAAIA,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA/B,EAAoC;QAClCA,KAAK,GAAI,KAAIA,KAAM,EAAnB;MACD;;MAED,MAAM+G,KAAK,GAAGtH,uBAAuB,CAACuH,IAAxB,CAA6BzC,SAAS,EAAtC,CAAd;;MACA,IAAIwC,KAAJ,EAAW;QACT/G,KAAK,IAAI+G,KAAK,CAAC,CAAD,CAAd;QACA3D,KAAK,CAACC,KAAN,IAAe0D,KAAK,CAAC,CAAD,CAAL,CAAS5F,MAAxB;MACD;;MAED6D,IAAI,CAAC;QAAExE,IAAI,EAAE,MAAR;QAAgBR;MAAhB,CAAD,CAAJ;MACA;IACD;IAED;AACJ;AACA;;;IAEI,IAAIkE,IAAI,KAAKA,IAAI,CAAC1D,IAAL,KAAc,UAAd,IAA4B0D,IAAI,CAAClB,IAAL,KAAc,IAA/C,CAAR,EAA8D;MAC5DkB,IAAI,CAAC1D,IAAL,GAAY,MAAZ;MACA0D,IAAI,CAAClB,IAAL,GAAY,IAAZ;MACAkB,IAAI,CAAClE,KAAL,IAAcA,KAAd;MACAkE,IAAI,CAAC5C,MAAL,GAAc0B,IAAd;MACAI,KAAK,CAACK,SAAN,GAAkB,IAAlB;MACAL,KAAK,CAACR,QAAN,GAAiB,IAAjB;MACA6B,OAAO,CAACzE,KAAD,CAAP;MACA;IACD;;IAED,IAAI6F,IAAI,GAAGtB,SAAS,EAApB;;IACA,IAAI1D,IAAI,CAACsC,SAAL,KAAmB,IAAnB,IAA2B,UAAU6C,IAAV,CAAeH,IAAf,CAA/B,EAAqD;MACnDL,WAAW,CAAC,MAAD,EAASxF,KAAT,CAAX;MACA;IACD;;IAED,IAAIkE,IAAI,CAAC1D,IAAL,KAAc,MAAlB,EAA0B;MACxB,IAAIK,IAAI,CAACmI,UAAL,KAAoB,IAAxB,EAA8B;QAC5BvE,OAAO,CAACzE,KAAD,CAAP;QACA;MACD;;MAED,MAAMiJ,KAAK,GAAG/E,IAAI,CAACA,IAAnB;MACA,MAAMgF,MAAM,GAAGD,KAAK,CAAC/E,IAArB;MACA,MAAMiF,OAAO,GAAGF,KAAK,CAACzI,IAAN,KAAe,OAAf,IAA0ByI,KAAK,CAACzI,IAAN,KAAe,KAAzD;MACA,MAAM4I,SAAS,GAAGF,MAAM,KAAKA,MAAM,CAAC1I,IAAP,KAAgB,MAAhB,IAA0B0I,MAAM,CAAC1I,IAAP,KAAgB,UAA/C,CAAxB;;MAEA,IAAIK,IAAI,CAACoC,IAAL,KAAc,IAAd,KAAuB,CAACkG,OAAD,IAAatD,IAAI,CAAC,CAAD,CAAJ,IAAWA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA3D,CAAJ,EAAsE;QACpEb,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAE;QAA/B,CAAD,CAAJ;QACA;MACD;;MAED,MAAM8D,OAAO,GAAGhC,KAAK,CAACQ,MAAN,GAAe,CAAf,KAAqBqF,KAAK,CAACzI,IAAN,KAAe,OAAf,IAA0ByI,KAAK,CAACzI,IAAN,KAAe,OAA9D,CAAhB;MACA,MAAM6E,SAAS,GAAGrB,QAAQ,CAAC7C,MAAT,KAAoB8H,KAAK,CAACzI,IAAN,KAAe,MAAf,IAAyByI,KAAK,CAACzI,IAAN,KAAe,OAA5D,CAAlB;;MACA,IAAI,CAAC2I,OAAD,IAAYF,KAAK,CAACzI,IAAN,KAAe,OAA3B,IAAsC,CAAC4E,OAAvC,IAAkD,CAACC,SAAvD,EAAkE;QAChEL,IAAI,CAAC;UAAExE,IAAI,EAAE,MAAR;UAAgBR,KAAhB;UAAuBsB,MAAM,EAAE;QAA/B,CAAD,CAAJ;QACA;MACD,CArBuB,CAuBxB;;;MACA,OAAOuE,IAAI,CAACrB,KAAL,CAAW,CAAX,EAAc,CAAd,MAAqB,KAA5B,EAAmC;QACjC,MAAM6E,KAAK,GAAG1I,KAAK,CAACyC,KAAK,CAACC,KAAN,GAAc,CAAf,CAAnB;;QACA,IAAIgG,KAAK,IAAIA,KAAK,KAAK,GAAvB,EAA4B;UAC1B;QACD;;QACDxD,IAAI,GAAGA,IAAI,CAACrB,KAAL,CAAW,CAAX,CAAP;QACAC,OAAO,CAAC,KAAD,EAAQ,CAAR,CAAP;MACD;;MAED,IAAIwE,KAAK,CAACzI,IAAN,KAAe,KAAf,IAAwB2D,GAAG,EAA/B,EAAmC;QACjCD,IAAI,CAAC1D,IAAL,GAAY,UAAZ;QACA0D,IAAI,CAAClE,KAAL,IAAcA,KAAd;QACAkE,IAAI,CAAC5C,MAAL,GAAcsB,QAAQ,CAAC/B,IAAD,CAAtB;QACAuC,KAAK,CAAC9B,MAAN,GAAe4C,IAAI,CAAC5C,MAApB;QACA8B,KAAK,CAACR,QAAN,GAAiB,IAAjB;QACA6B,OAAO,CAACzE,KAAD,CAAP;QACA;MACD;;MAED,IAAIiJ,KAAK,CAACzI,IAAN,KAAe,OAAf,IAA0ByI,KAAK,CAAC/E,IAAN,CAAW1D,IAAX,KAAoB,KAA9C,IAAuD,CAAC4I,SAAxD,IAAqEjF,GAAG,EAA5E,EAAgF;QAC9Ef,KAAK,CAAC9B,MAAN,GAAe8B,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAACyE,KAAK,CAAC3H,MAAN,GAAe4C,IAAI,CAAC5C,MAArB,EAA6BH,MAApD,CAAf;QACA8H,KAAK,CAAC3H,MAAN,GAAgB,MAAK2H,KAAK,CAAC3H,MAAO,EAAlC;QAEA4C,IAAI,CAAC1D,IAAL,GAAY,UAAZ;QACA0D,IAAI,CAAC5C,MAAL,GAAcsB,QAAQ,CAAC/B,IAAD,CAAR,IAAkBA,IAAI,CAACyI,aAAL,GAAqB,GAArB,GAA2B,KAA7C,CAAd;QACApF,IAAI,CAAClE,KAAL,IAAcA,KAAd;QACAoD,KAAK,CAACR,QAAN,GAAiB,IAAjB;QACAQ,KAAK,CAAC9B,MAAN,IAAgB2H,KAAK,CAAC3H,MAAN,GAAe4C,IAAI,CAAC5C,MAApC;QACAmD,OAAO,CAACzE,KAAD,CAAP;QACA;MACD;;MAED,IAAIiJ,KAAK,CAACzI,IAAN,KAAe,OAAf,IAA0ByI,KAAK,CAAC/E,IAAN,CAAW1D,IAAX,KAAoB,KAA9C,IAAuDqF,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAvE,EAA4E;QAC1E,MAAM0D,GAAG,GAAG1D,IAAI,CAAC,CAAD,CAAJ,KAAY,KAAK,CAAjB,GAAqB,IAArB,GAA4B,EAAxC;QAEAzC,KAAK,CAAC9B,MAAN,GAAe8B,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAACyE,KAAK,CAAC3H,MAAN,GAAe4C,IAAI,CAAC5C,MAArB,EAA6BH,MAApD,CAAf;QACA8H,KAAK,CAAC3H,MAAN,GAAgB,MAAK2H,KAAK,CAAC3H,MAAO,EAAlC;QAEA4C,IAAI,CAAC1D,IAAL,GAAY,UAAZ;QACA0D,IAAI,CAAC5C,MAAL,GAAe,GAAEsB,QAAQ,CAAC/B,IAAD,CAAO,GAAEqB,aAAc,IAAGA,aAAc,GAAEqH,GAAI,GAAvE;QACArF,IAAI,CAAClE,KAAL,IAAcA,KAAd;QAEAoD,KAAK,CAAC9B,MAAN,IAAgB2H,KAAK,CAAC3H,MAAN,GAAe4C,IAAI,CAAC5C,MAApC;QACA8B,KAAK,CAACR,QAAN,GAAiB,IAAjB;QAEA6B,OAAO,CAACzE,KAAK,GAAGsE,OAAO,EAAhB,CAAP;QAEAU,IAAI,CAAC;UAAExE,IAAI,EAAE,OAAR;UAAiBR,KAAK,EAAE,GAAxB;UAA6BsB,MAAM,EAAE;QAArC,CAAD,CAAJ;QACA;MACD;;MAED,IAAI2H,KAAK,CAACzI,IAAN,KAAe,KAAf,IAAwBqF,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAxC,EAA6C;QAC3C3B,IAAI,CAAC1D,IAAL,GAAY,UAAZ;QACA0D,IAAI,CAAClE,KAAL,IAAcA,KAAd;QACAkE,IAAI,CAAC5C,MAAL,GAAe,QAAOY,aAAc,IAAGU,QAAQ,CAAC/B,IAAD,CAAO,GAAEqB,aAAc,GAAtE;QACAkB,KAAK,CAAC9B,MAAN,GAAe4C,IAAI,CAAC5C,MAApB;QACA8B,KAAK,CAACR,QAAN,GAAiB,IAAjB;QACA6B,OAAO,CAACzE,KAAK,GAAGsE,OAAO,EAAhB,CAAP;QACAU,IAAI,CAAC;UAAExE,IAAI,EAAE,OAAR;UAAiBR,KAAK,EAAE,GAAxB;UAA6BsB,MAAM,EAAE;QAArC,CAAD,CAAJ;QACA;MACD,CApFuB,CAsFxB;;;MACA8B,KAAK,CAAC9B,MAAN,GAAe8B,KAAK,CAAC9B,MAAN,CAAakD,KAAb,CAAmB,CAAnB,EAAsB,CAACN,IAAI,CAAC5C,MAAL,CAAYH,MAAnC,CAAf,CAvFwB,CAyFxB;;MACA+C,IAAI,CAAC1D,IAAL,GAAY,UAAZ;MACA0D,IAAI,CAAC5C,MAAL,GAAcsB,QAAQ,CAAC/B,IAAD,CAAtB;MACAqD,IAAI,CAAClE,KAAL,IAAcA,KAAd,CA5FwB,CA8FxB;;MACAoD,KAAK,CAAC9B,MAAN,IAAgB4C,IAAI,CAAC5C,MAArB;MACA8B,KAAK,CAACR,QAAN,GAAiB,IAAjB;MACA6B,OAAO,CAACzE,KAAD,CAAP;MACA;IACD;;IAED,MAAM4E,KAAK,GAAG;MAAEpE,IAAI,EAAE,MAAR;MAAgBR,KAAhB;MAAuBsB,MAAM,EAAE0B;IAA/B,CAAd;;IAEA,IAAInC,IAAI,CAACoC,IAAL,KAAc,IAAlB,EAAwB;MACtB2B,KAAK,CAACtD,MAAN,GAAe,KAAf;;MACA,IAAI4C,IAAI,CAAC1D,IAAL,KAAc,KAAd,IAAuB0D,IAAI,CAAC1D,IAAL,KAAc,OAAzC,EAAkD;QAChDoE,KAAK,CAACtD,MAAN,GAAewB,KAAK,GAAG8B,KAAK,CAACtD,MAA7B;MACD;;MACD0D,IAAI,CAACJ,KAAD,CAAJ;MACA;IACD;;IAED,IAAIV,IAAI,KAAKA,IAAI,CAAC1D,IAAL,KAAc,SAAd,IAA2B0D,IAAI,CAAC1D,IAAL,KAAc,OAA9C,CAAJ,IAA8DK,IAAI,CAACkI,KAAL,KAAe,IAAjF,EAAuF;MACrFnE,KAAK,CAACtD,MAAN,GAAetB,KAAf;MACAgF,IAAI,CAACJ,KAAD,CAAJ;MACA;IACD;;IAED,IAAIxB,KAAK,CAACC,KAAN,KAAgBD,KAAK,CAACE,KAAtB,IAA+BY,IAAI,CAAC1D,IAAL,KAAc,OAA7C,IAAwD0D,IAAI,CAAC1D,IAAL,KAAc,KAA1E,EAAiF;MAC/E,IAAI0D,IAAI,CAAC1D,IAAL,KAAc,KAAlB,EAAyB;QACvB4C,KAAK,CAAC9B,MAAN,IAAgBgB,YAAhB;QACA4B,IAAI,CAAC5C,MAAL,IAAegB,YAAf;MAED,CAJD,MAIO,IAAIzB,IAAI,CAACgC,GAAL,KAAa,IAAjB,EAAuB;QAC5BO,KAAK,CAAC9B,MAAN,IAAgBiB,aAAhB;QACA2B,IAAI,CAAC5C,MAAL,IAAeiB,aAAf;MAED,CAJM,MAIA;QACLa,KAAK,CAAC9B,MAAN,IAAgBwB,KAAhB;QACAoB,IAAI,CAAC5C,MAAL,IAAewB,KAAf;MACD;;MAED,IAAIsB,IAAI,OAAO,GAAf,EAAoB;QAClBhB,KAAK,CAAC9B,MAAN,IAAgBa,QAAhB;QACA+B,IAAI,CAAC5C,MAAL,IAAea,QAAf;MACD;IACF;;IAED6C,IAAI,CAACJ,KAAD,CAAJ;EACD;;EAED,OAAOxB,KAAK,CAACO,QAAN,GAAiB,CAAxB,EAA2B;IACzB,IAAI9C,IAAI,CAAC2G,cAAL,KAAwB,IAA5B,EAAkC,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;IAClC6C,KAAK,CAAC9B,MAAN,GAAehC,KAAK,CAACkK,UAAN,CAAiBpG,KAAK,CAAC9B,MAAvB,EAA+B,GAA/B,CAAf;IACA2D,SAAS,CAAC,UAAD,CAAT;EACD;;EAED,OAAO7B,KAAK,CAACS,MAAN,GAAe,CAAtB,EAAyB;IACvB,IAAIhD,IAAI,CAAC2G,cAAL,KAAwB,IAA5B,EAAkC,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;IAClC6C,KAAK,CAAC9B,MAAN,GAAehC,KAAK,CAACkK,UAAN,CAAiBpG,KAAK,CAAC9B,MAAvB,EAA+B,GAA/B,CAAf;IACA2D,SAAS,CAAC,QAAD,CAAT;EACD;;EAED,OAAO7B,KAAK,CAACQ,MAAN,GAAe,CAAtB,EAAyB;IACvB,IAAI/C,IAAI,CAAC2G,cAAL,KAAwB,IAA5B,EAAkC,MAAM,IAAIpG,WAAJ,CAAgBb,WAAW,CAAC,SAAD,EAAY,GAAZ,CAA3B,CAAN;IAClC6C,KAAK,CAAC9B,MAAN,GAAehC,KAAK,CAACkK,UAAN,CAAiBpG,KAAK,CAAC9B,MAAvB,EAA+B,GAA/B,CAAf;IACA2D,SAAS,CAAC,QAAD,CAAT;EACD;;EAED,IAAIpE,IAAI,CAACyI,aAAL,KAAuB,IAAvB,KAAgCpF,IAAI,CAAC1D,IAAL,KAAc,MAAd,IAAwB0D,IAAI,CAAC1D,IAAL,KAAc,SAAtE,CAAJ,EAAsF;IACpFwE,IAAI,CAAC;MAAExE,IAAI,EAAE,aAAR;MAAuBR,KAAK,EAAE,EAA9B;MAAkCsB,MAAM,EAAG,GAAEY,aAAc;IAA3D,CAAD,CAAJ;EACD,CA75B+B,CA+5BhC;;;EACA,IAAIkB,KAAK,CAACK,SAAN,KAAoB,IAAxB,EAA8B;IAC5BL,KAAK,CAAC9B,MAAN,GAAe,EAAf;;IAEA,KAAK,MAAMsD,KAAX,IAAoBxB,KAAK,CAAC5B,MAA1B,EAAkC;MAChC4B,KAAK,CAAC9B,MAAN,IAAgBsD,KAAK,CAACtD,MAAN,IAAgB,IAAhB,GAAuBsD,KAAK,CAACtD,MAA7B,GAAsCsD,KAAK,CAAC5E,KAA5D;;MAEA,IAAI4E,KAAK,CAAC6E,MAAV,EAAkB;QAChBrG,KAAK,CAAC9B,MAAN,IAAgBsD,KAAK,CAAC6E,MAAtB;MACD;IACF;EACF;;EAED,OAAOrG,KAAP;AACD,CA76BD;AA+6BA;AACA;AACA;AACA;AACA;;;AAEA1C,KAAK,CAACwF,SAAN,GAAkB,CAACvF,KAAD,EAAQb,OAAR,KAAoB;EACpC,MAAMe,IAAI,GAAG,EAAE,GAAGf;EAAL,CAAb;EACA,MAAMgB,GAAG,GAAG,OAAOD,IAAI,CAACE,SAAZ,KAA0B,QAA1B,GAAqCC,IAAI,CAACC,GAAL,CAAS1B,UAAT,EAAqBsB,IAAI,CAACE,SAA1B,CAArC,GAA4ExB,UAAxF;EACA,MAAM2B,GAAG,GAAGP,KAAK,CAACQ,MAAlB;;EACA,IAAID,GAAG,GAAGJ,GAAV,EAAe;IACb,MAAM,IAAIM,WAAJ,CAAiB,iBAAgBF,GAAI,qCAAoCJ,GAAI,EAA7E,CAAN;EACD;;EAEDH,KAAK,GAAGhB,YAAY,CAACgB,KAAD,CAAZ,IAAuBA,KAA/B;EACA,MAAMe,KAAK,GAAGpC,KAAK,CAACqC,SAAN,CAAgB7B,OAAhB,CAAd,CAToC,CAWpC;;EACA,MAAM;IACJkC,WADI;IAEJE,aAFI;IAGJC,QAHI;IAIJC,UAJI;IAKJC,MALI;IAMJqH,OANI;IAOJnH,aAPI;IAQJG,IARI;IASJC;EATI,IAUFvD,SAAS,CAACyC,SAAV,CAAoBH,KAApB,CAVJ;EAYA,MAAMoB,KAAK,GAAGjC,IAAI,CAACgC,GAAL,GAAW6G,OAAX,GAAqBrH,MAAnC;EACA,MAAMsH,QAAQ,GAAG9I,IAAI,CAACgC,GAAL,GAAWN,aAAX,GAA2BF,MAA5C;EACA,MAAMZ,OAAO,GAAGZ,IAAI,CAACY,OAAL,GAAe,EAAf,GAAoB,IAApC;EACA,MAAM2B,KAAK,GAAG;IAAEM,OAAO,EAAE,KAAX;IAAkBF,MAAM,EAAE;EAA1B,CAAd;EACA,IAAIR,IAAI,GAAGnC,IAAI,CAACoC,IAAL,KAAc,IAAd,GAAqB,KAArB,GAA6BP,IAAxC;;EAEA,IAAI7B,IAAI,CAACY,OAAT,EAAkB;IAChBuB,IAAI,GAAI,IAAGA,IAAK,GAAhB;EACD;;EAED,MAAMJ,QAAQ,GAAG/B,IAAI,IAAI;IACvB,IAAIA,IAAI,CAACmI,UAAL,KAAoB,IAAxB,EAA8B,OAAOhG,IAAP;IAC9B,OAAQ,IAAGvB,OAAQ,SAAQkB,YAAa,GAAE9B,IAAI,CAACgC,GAAL,GAAWT,UAAX,GAAwBJ,WAAY,QAA9E;EACD,CAHD;;EAKA,MAAM4H,MAAM,GAAGC,GAAG,IAAI;IACpB,QAAQA,GAAR;MACE,KAAK,GAAL;QACE,OAAQ,GAAE/G,KAAM,GAAEX,QAAS,GAAEa,IAAK,EAAlC;;MAEF,KAAK,IAAL;QACE,OAAQ,GAAEhB,WAAY,GAAEG,QAAS,GAAEa,IAAK,EAAxC;;MAEF,KAAK,KAAL;QACE,OAAQ,GAAEF,KAAM,GAAEE,IAAK,GAAEhB,WAAY,GAAEG,QAAS,GAAEa,IAAK,EAAvD;;MAEF,KAAK,KAAL;QACE,OAAQ,GAAEF,KAAM,GAAEE,IAAK,GAAEd,aAAc,GAAEC,QAAS,GAAEwH,QAAS,GAAE3G,IAAK,EAApE;;MAEF,KAAK,IAAL;QACE,OAAOF,KAAK,GAAGF,QAAQ,CAAC/B,IAAD,CAAvB;;MAEF,KAAK,MAAL;QACE,OAAQ,MAAKiC,KAAM,GAAEF,QAAQ,CAAC/B,IAAD,CAAO,GAAEqB,aAAc,KAAIyH,QAAS,GAAExH,QAAS,GAAEa,IAAK,EAAnF;;MAEF,KAAK,QAAL;QACE,OAAQ,MAAKF,KAAM,GAAEF,QAAQ,CAAC/B,IAAD,CAAO,GAAEqB,aAAc,KAAIyH,QAAS,GAAE3G,IAAK,GAAEhB,WAAY,GAAEG,QAAS,GAAEa,IAAK,EAAxG;;MAEF,KAAK,OAAL;QACE,OAAQ,MAAKF,KAAM,GAAEF,QAAQ,CAAC/B,IAAD,CAAO,GAAEqB,aAAc,KAAIF,WAAY,GAAEG,QAAS,GAAEa,IAAK,EAAtF;;MAEF;QAAS;UACP,MAAM+D,KAAK,GAAG,iBAAiBC,IAAjB,CAAsB6C,GAAtB,CAAd;UACA,IAAI,CAAC9C,KAAL,EAAY;UAEZ,MAAM+C,MAAM,GAAGF,MAAM,CAAC7C,KAAK,CAAC,CAAD,CAAN,CAArB;UACA,IAAI,CAAC+C,MAAL,EAAa;UAEb,OAAOA,MAAM,GAAG9H,WAAT,GAAuB+E,KAAK,CAAC,CAAD,CAAnC;QACD;IAjCH;EAmCD,CApCD;;EAsCA,MAAMzF,MAAM,GAAGhC,KAAK,CAACyE,YAAN,CAAmBpD,KAAnB,EAA0ByC,KAA1B,CAAf;EACA,IAAI0G,MAAM,GAAGF,MAAM,CAACtI,MAAD,CAAnB;;EAEA,IAAIwI,MAAM,IAAIjJ,IAAI,CAACyI,aAAL,KAAuB,IAArC,EAA2C;IACzCQ,MAAM,IAAK,GAAE5H,aAAc,GAA3B;EACD;;EAED,OAAO4H,MAAP;AACD,CArFD;;AAuFAC,MAAM,CAACC,OAAP,GAAiBtJ,KAAjB"},"metadata":{},"sourceType":"script"}