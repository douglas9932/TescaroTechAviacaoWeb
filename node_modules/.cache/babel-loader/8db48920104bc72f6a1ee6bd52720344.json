{"ast":null,"code":"/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange.cache = {};\n\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nmodule.exports = toRegexRange;","map":{"version":3,"names":["isNumber","require","toRegexRange","min","max","options","TypeError","String","opts","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","result","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","length","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","concat","join","splitToRanges","nines","zeros","stop","countNines","stops","Set","add","countZeros","sort","compare","rangeToPattern","start","pattern","count","digits","zipped","zip","i","startDigit","stopDigit","toCharacterClass","tok","ranges","tokens","prev","obj","pop","push","string","toQuantifier","padZeros","arr","comparison","prefix","intersection","ele","contains","key","val","some","len","Number","slice","repeat","integer","pow","str","test","value","diff","clearCache","module","exports"],"sources":["C:/reactnative/TescaroTechAviacaoWeb/node_modules/to-regex-range/index.js"],"sourcesContent":["/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}